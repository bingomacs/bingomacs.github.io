<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Go语言开发环境搭建]]></title>
    <url>%2F2017%2F08%2F12%2FGo%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Go语言简介Go 是一门开源，在语言层上支持并发，带垃圾回收的新型编译型语言。Go 语言是 Google 开发的，其性能可以与 C/C++ 媲美。具有动态语言的开发效率，静态语言的安全性。 安装Mac 下安装 使用homebrew安装，如果不知道homebrew是什么，请使用搜索解决。1brew install go Linux（Ubuntu）下安装 下载安装包下载地址在下载地址中根据自己电脑的系统选择对应的下载 解压下载的安装包到/usr/local1tar -C /usr/local/ -xzf go$VERSION.$OS-$ARCH.tar.gz #把`go$VERSION.$OS-$ARCH.tar.gz`换成你下载的文件名 配置环境变量 编辑vi ~/.bashrc，如果没有自己手动创建。在文件的末尾加入下面的语句。 123456789# GOROOT Go 语言的安装目录，根据自己的系统选择对应的命令export GOROOT=/usr/local/opt/go/libexec # Mac 下使用`homebrew`安装的配置export GOROOT=/usr/local/go # Linux 下的配置# Go 语言二进制目录export GOBIN=$GOROOT/bin# 加入到 PATH 中export PATH=$PATH:$GOBIN # GOPATH Go 语言的工作目录(可选)export GOPATH=/home/$USER/go # 可以根据自己喜好设置 GOPATH 的路径。从go 1.8开始，GOPATH 默认为$HOME/go。 使配置的环境变量立即生效 1source ~/.bashrc 验证是否安装成功 1go version 如果输出类似下面的内容则安装成功 1go version go1.8.3 darwin/amd64 GOPATH 结构 GOPATH 是 Go 语言的工作目录，在 GOPATH 下有三个重要的子目录分别是src、pkg、bin。 src存放 Go 语言的源代码 pkg存放编译后生成的文件 bin存放编译后生成的可执行文件 安装 GoSublime 插件（默认安装好了 SublimeText3）GoSublime 是 Sublime Text 3 的一个插件，装上该插件可以有代码提示的功能。 启用 package control,按下 Ctrl + ` ,输入 1import urllib.request,os,hashlib; h = 'df21e130d211cfc94d9b0905775a7c0f' + '1e3d39e33b79698005270310898eea76'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) 安装 GoSublime在 sublime 中同时按住 cmd + shift + p,在弹出的框中输入install package,需要等待一会搜索包，搜索完毕后在输入框中输入 gosublime ，选中第一个，回车安装好了重启生效 配置 GoSublime在菜单中选择 Preferences -&gt; package settings -&gt; GoSublime -&gt; Settings -&gt; Uesrs在打开的文件中输入 123456&#123; "env": &#123; "GOPATH": "~/go",//根据自己的路径修改 "GOROOT": "/usr/local/opt/go/libexec" &#125;&#125; 运行在 GOPATH 中新建一个 hello.go 文件，输入 12345package mainimport ("fmt")func main()&#123; fmt.Print("hello go")&#125; 在 sublime 中 按住cmd+b后输入 go run hello.go 就可以看都控制台打印了 hello go]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派入门]]></title>
    <url>%2F2017%2F05%2F22%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[树莓派的简单介绍 Raspberry Pi(中文名为“树莓派”,简写为RPi，(或者RasPi / RPI)是为学生计算机编程教育而设计，只有信用卡大小的卡片式电脑，其系统基于Linux。—— 来自百度百科的介绍 安装前准备 树莓派一个（当然你要有电源适配器，没有的话移动电源也可以） SD 卡一张，树莓派使用 SD 卡作为容量，没有的 SD 卡是没法用的。（SD 卡要自己想办法连上电脑，用来烧写系统） 网线一根，用于设置 WiFi 镜像的选择镜像下载地址在地址中选择一个合适的镜像下载到本地，我选择的是 Raspbian 制作系统（MacOS 环境下制作） 在制作之前先看看有哪些磁盘diskutil list 把 SD 卡连接电脑，SD 卡需要 FAT32 格式的 再使用diskutil list查看一下多出来的就是我们要的。例如 /dev/disk2 使用diskutil unmountDisk /dev/disk&lt;disk# from diskutil&gt;来卸载分区，其中&lt;disk# from diskutil&gt;是 SD 卡的分区，不是disk2之类的，而是类似disk2s1这样的。 使用sudo dd bs=1m if=~/Downloads/2017-04-10-raspbian-jessie.img of=/dev/disk2把镜像拷贝到 SD 卡。其中if后面接的是镜像的路径，of接的是 SD 卡的路径，要根据自己镜像和 SD 卡的位置填写。bs（block size）后面接的是块的大小，照着写不必理会。这个过程比较久，需要耐心等待。 开机并使用 SSH 远程登录 把 SD 卡装进树莓派、并接上网线，并通电。 树莓派默认的账号是pi,密码是raspberry 登录之前需要知道树莓派的 IP 地址，可以使用arp -a来查看（多试几次），如果你可以登录路由器后台也可以很方便的查看到树莓派的 IP。 在终端中输入ssh pi@ip，ip就是上一步获取到的，如果你直接这样连接恐怕是连不上的。最新的 Raspbian 镜像默认禁用了 SSH 服务。开启 SSH 很简单只要在 SD 卡的根目录建立一个ssh的文件夹就行了。 配置 WiFi编辑etc/wpa_supplicant/wpa_supplicant.conf,在文件后面追加123456network=&#123; ssid="WIFINAME" # WIFI 的名字 psk="password" # WIFI 的密码 key_mgmt=WPA-PSK # 加密类型，照着写好了，一般不用改。如果想看的话，用手机连上该 WIFI 详细里面的安全性就指的是这个。 priority=1 # 连接的优先级，数值越大，优先级越高。&#125; 写好保存，重启生效]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>Raspberry Pi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tmux]]></title>
    <url>%2F2017%2F05%2F18%2FTmux%2F</url>
    <content type="text"><![CDATA[做开发经常需要在各种环境中切来切去，回来的时候环境已经变了，Tmux 可以创建多个会话在不同环境中切换。 什么是Tmux来自 Tmux 自述 tmux is a terminal multiplexer: it enables a number of terminals to be created, accessed, and controlled from a single screen. tmux may be detached from a screen and continue running in the background, then later reattached. 说人话Tmux 是终端复用器，它使多个终端被创建，访问，并从单一屏幕控制。Tmux 可以从屏幕分离并继续在后台运行，然后重新连接。 有什么用举个例子：你连上服务器后做了一会事情要回到本地做一些操作，通常做法是先断开服务器的连接，做完本地操作后再连上服务器继续操作。这样做太费事了。Tmux 就是解决这件事的，它可以让你不需要断开连接就可以在本地做你想做的，就算意外断开连接也能恢复。(当然关机就不行了，但是你可以通过写脚本来恢复) 怎么用名词解释Session：用来管理窗口的，一个 Session 可包含多个 Window。Window：当前正在操作的窗口，一个 window 可包含多个 pane。Pane：window 被分割后的小窗口。Prefix：前缀键CTRL+b，表示同时按下 CTRL 和 b。下文使用 Prefix 代替 CTRL+b 安装Macbrew install tmux Linux（Ubuntu）sudo apt install tmux 基本使用安装好 Tmux 后在终端中输入tmux就可以开始使用，默认会创建一个 Session。 可以使用tmux new -s name在创建 Session 的时候并命名,name就是该 Session 的名字 Session 相关 新建 SessionPrefix :new -s name 其中name是 Session 的名字，这条指令是在Tmux的环境中使用，和基本使用中的不一样。这条指令表示先按下Prefix（CTRL+b），松开之后再输入:new -s name。后面以此类推。 列出当前 SessionPrefix s,在终端环境中使用tmux ls查看 暂时离开 SessionPrefix d 接入之前的 Session tmux a -t name,只有一个 Session 的时候可以省略name（终端环境中） 重命名 SessionPrefix $ 关闭 Session Prefix :kill-session -t name Window 相关 新建 Window Prefix c 列出当前 Window Prefix w 重命名当前 Window Prefix , 关闭 Window Prefix &amp; 上一个 Window Prefix p 下一个 Window Prefix n Pane 相关 水平分割 Window Prefix &quot; 垂直分割 Window Prefix % 关闭 Pane Prefix x 把 Pane 最大化 / 最小化 Prefix z 把 Pane 移动到左边 Prefix { 把 Pane 移动到右边 Prefix } 切换到下一个 Pane Prefix o 参考Tmux - Linux从业者必备利器 优雅地使用命令行：Tmux 终端复用]]></content>
      <categories>
        <category>工具 效率</category>
      </categories>
      <tags>
        <tag>工具 效率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 使用小记]]></title>
    <url>%2F2017%2F04%2F22%2FDocker%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Docker 简介Docker 是一个开源的应用容器引擎。可以看成是一个特殊的环境，隔离了宿主机（电脑）和容器。做开发的时候通常会碰到在自己的电脑上没问题，放到服务器或者别人的电脑上就出问题了，有了 Docker 这些问题迎刃而解。经常在 Linux 上做一些测试，做完测试就不用了。如果用虚拟机，不但占据者比较大的磁盘空间，而且运行启动耗时较长，性能不高。用 Docker 可以随时随地启动一个 Linux 的容器，用完就可以删除，下次要用在重新开启一个新的，速度非常快。 Docker 比虚拟机来的轻巧，开启和关闭非常迅速，占用的资源少。 Docker 安装（Ubuntu 16.04）安装之前卸载旧版本（如果有的话）1sudo apt-get remove docker docker-engine docker.io 使用阿里云提供的安装脚本（由于网络问题，你懂得）1curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh - Docker 需要安装在 64 位的 x86 平台或 ARM 平台上（如树莓派），内核版本不低于 3.10。 手动安装12345678910111213sudo apt-get updatesudo apt-get install apt-transport-https ca-certificates curl software-properties-commoncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -sudo add-apt-repository \ "deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable"sudo apt-get updatesudo apt-get install docker-ce# 启动sudo systemctl start docker# 查看 docker 版本docker --version 小试牛刀，运行一个容器1docker run hello-world 建立 Docker 用户组为什么要建立 Docker 用户组 默认情况下，只有 root 用户和 docker 组的用户才可以访问 Docker。一般不会直接使用 root 用户操作，也避免每次输入命令都要加su. 建立 docker 组sudo groupadd docker 将当前用户加入 docker 组：sudo usermod -aG docker $USER Docker 名词解释镜像(Image)Docker 镜像可以理解为模板，就像面向对象里的class一样可以通过这个类创建出无数个对象（容器）。 容器(Container)Docker 容器就是通过镜像创建出来的运行实例，与面向对象里的对象类似。不过容器可以作为新的镜像用来创建新的容器。 仓库(Registry)Docker 仓库是一个镜像的集合，里面放了许多常用的镜像，不要我们自己去构建这些镜像。比如 Ubuntu、Tomcat等。一个仓库可能包含不同版本的镜像，在镜像仓库里不同的版本会被打上不同的标签。我们可以通过镜像名:标签来获取不版本的镜像。以 Ubuntu 为例，Ubuntu 16.04 的版本表示为ubuntu:16.04。如果没有写标签，表示使用最新的。即ubuntu:latest 使用镜像的管理 查看所有镜像 1docker images 获取镜像，Docker Registry 默认为 Docker Hub，镜像名由用户名/软件名组成，不写用户名默认为library，也就是官方镜像 1docker pull [Docker Registry]&lt;镜像&gt;:&lt;标签&gt; 删除镜像 1docker rmi &lt;镜像&gt; 容器的使用与管理 查看所有容器,包括没有在运行的 1docker ps -a 运行容器 1docker run ubuntu 运行交互式容器,i交互是操作，t终端。后面的bash表示用bash做为交互式终端的shell 1docker run -it ubuntu bash 运行完容器后删除,不保留运行的结果 1docker run -rm ubuntu 运行容器，并指定端口映射。p小写 1docker run -p 8080:8080 nginx 运行容器，随机映射端口。P大写 1docker run -P nginx 为容器起一个别名 1docker run --name alias nginx 后台运行容器。容器是否长久运行和-d无关，-d只是指定了运行在后台（background）。容器长久运行和run指定的命令有关。后台运行可以在本地和容器之间来回切换。 1docker run -d ubuntu 进入后台运行的容器 1docker attach ubuntu 停止容器 1docker stop ubuntu 删除容器 1docker rm ubuntu 参考Docker — 从入门到实践]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Mac 终端中使用代理]]></title>
    <url>%2F2017%2F03%2F09%2F%E5%9C%A8mac%E7%BB%88%E7%AB%AF%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[作为一个程序员，天天和终端打交道。可是在 Mac 终端下使用 brew 安装软件却十分慢，即便你使用 ShadowSocks 配置了全局代理，却发现这么做依然没有效果，下载还是龟速。虽然可以通过配置国内的镜像来解决，但是后期下载还是很慢，效果就不好了。 简单使用在终端使用 ShadowSocks 十分简单，只需在终端中输入下列指令就可1export ALL_PROXY = socks5://127.0.0.1:1080 现在可以试试 brew 更新软件了，速度蹭蹭的往上涨 不想用代理了，输入下面指令即可1unset ALL_PROXY 优化每次想要使用代理的时候都要输入这么多记不住把下面的命令保存到 ~/.bash_profile 如果使用的是zsh则保存到 ~/.zshrc12alias socks5 = "export ALL_PROXY=socks5://127.0.0.1:1080"alias unsocks5 = "unset ALL_PROXY" 想要立即生效 source .zshrc 或者 source .bash_profile以后想要打开代理只需输 socks5关闭只需输 unsocks5]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 网络服务发现（NSD）]]></title>
    <url>%2F2016%2F10%2F03%2FAndroid%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[这些日子碰到这样一个需求，需要在局域网中发现我们创建的某个特定设备，并连上互相通信。本以为要去遍历整个局域网，后来查阅相关资料后发现 Android 为我们提供了网络服务发现（Network Service Discovery）简称 NSD，就是本文要讲的东西了。 NSD 有什么用用来扫描局域网中特定的服务，并与之通信。省去了自己去写发现协议。 NSD 怎么用创建我们需要提供的服务首先要创建一个 ServerSocket，用来等待别人的连接123456789101112/** *创建一个server来获取端口 */private void createServerSocket() &#123; if (mServerSocket != null) return; try &#123; mServerSocket = new ServerSocket(0);//设为0,会自动获取没有占用的端口 mPort = mServerSocket.getLocalPort(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 接下来就可以创建 NsdServiceInfo 了，NsdServiceInfo 是一个包含 Nsd 服务信息的类,看名字就知道了。12345678910/** *创建NsdServiceInfo */private void createNsdServiceInfo() &#123; if (mNsdServiceInfo != null) return; mNsdServiceInfo = new NsdServiceInfo(); mNsdServiceInfo.setServiceName(SERVICE_NAME);//设置服务的名字，被别的机器发现时显示的名字。 mNsdServiceInfo.setServiceType(SERVICE_TYPE); mNsdServiceInfo.setPort(mPort);&#125; 在服务端注册 NSD 服务12345678910111213141516171819202122232425private void register() &#123; mNsdManager = (NsdManager) getSystemService(NSD_SERVICE); mNsdManager.registerService(mNsdServiceInfo, NsdManager.PROTOCOL_DNS_SD,mRegistrationListener);&#125;private void createRegistration() &#123; mRegistrationListener = new NsdManager.RegistrationListener() &#123; @Override public void onRegistrationFailed(NsdServiceInfo nsdServiceInfo, int i)&#123; Toast.makeText(MainActivity.this, "onRegistrationFailed", Toast.LENGTH_SHORT).show(); &#125; @Override public void onUnregistrationFailed(NsdServiceInfo nsdServiceInfo, int i) &#123; Toast.makeText(MainActivity.this, "onUnregistrationFailed", Toast.LENGTH_SHORT).show(); &#125; @Override public void onServiceRegistered(NsdServiceInfo nsdServiceInfo) &#123; Toast.makeText(MainActivity.this, "onServiceRegistered", Toast.LENGTH_SHORT).show(); new Thread(MainActivity.this).start(); &#125; @Override public void onServiceUnregistered(NsdServiceInfo nsdServiceInfo) &#123; Toast.makeText(MainActivity.this, "onServiceUnregistered", Toast.LENGTH_SHORT).show(); &#125; &#125;;&#125; 在客户端发现 NSD 服务12345678910111213141516171819202122232425262728293031nsdManager.discoverServices(SERVICE_TYPE, NsdManager.PROTOCOL_DNS_SD, mDiscoveryListener);private void createDiscoverListener() &#123; mDiscoveryListener = new NsdManager.DiscoveryListener() &#123; @Override public void onStartDiscoveryFailed(String s, int i) &#123; Toast.makeText(MainActivity.this, "onStartDiscoveryFailed", Toast.LENGTH_SHORT).show(); &#125; @Override public void onStopDiscoveryFailed(String s, int i) &#123; Toast.makeText(MainActivity.this, "onStopDiscoveryFailed", Toast.LENGTH_SHORT).show(); &#125; @Override public void onDiscoveryStarted(String s) &#123; Toast.makeText(MainActivity.this, "onDiscoveryStarted", Toast.LENGTH_SHORT).show(); &#125; @Override public void onDiscoveryStopped(String s) &#123; Toast.makeText(MainActivity.this, "onDiscoveryStopped", Toast.LENGTH_SHORT).show(); &#125; @Override public void onServiceFound(NsdServiceInfo nsdServiceInfo) &#123; //这里的nsdServiceInfo只能获取到名字,ip和端口都不能获取到,要想获取到需要调用NsdManager.resolveService方法 datas.add(nsdServiceInfo); mHandler.sendEmptyMessage(0); &#125; @Override public void onServiceLost(NsdServiceInfo nsdServiceInfo) &#123; Toast.makeText(MainActivity.this, "onServiceLost", Toast.LENGTH_SHORT).show(); &#125; &#125;;&#125; 获取服务的详细信息1234567891011121314nsdManager.resolveService(nsdServiceInfo, mResolverListener);private void createResolverListener() &#123; mResolverListener = new NsdManager.ResolveListener() &#123; @Override public void onResolveFailed(NsdServiceInfo nsdServiceInfo, int i) &#123; Toast.makeText(MainActivity.this, "onResolveFailed", Toast.LENGTH_SHORT).show(); &#125; @Override public void onServiceResolved(NsdServiceInfo nsdServiceInfo) &#123; mNsdServiceInfo = nsdServiceInfo; new Thread(MainActivity.this).start(); &#125; &#125;;&#125; 连接1234mSocket = new Socket(mNsdServiceInfo.getHost().getHostAddress(), mNsdServiceInfo.getPort());bufferedWriter = new BufferedWriter(new OutputStreamWriter(mSocket.getOutputStream()));bufferedWriter.write("我连上你了!" + "\n");bufferedWriter.flush(); 效果图 相关资料链接 demo地址 官网资料需自备梯子]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 Hexo 搭建博客]]></title>
    <url>%2F2016%2F10%2F01%2Fhexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[安装 Hexo 前环境的搭建Node.js 的安装1brew install node ps：如果没有安装 brew 请移步 Homebrew 安装 Git，当然你还得有 GitHub 账号安装过 Xcode 的可以跳过这一步，Xcode 的自带 Git。没安装的可以安装 Xcode 也可以使用下面的命令安装1brew install git 安装 Hexo12//安装到全局npm install -g hexo-cli 初始化 Hexo初始化当前目录1hexo init "文件夹" //如果文件夹为空，则为当前目录(文件夹不要带引号) 安装依赖包12//进入到上一步初始化的文件夹下npm install 配置进入到初始化的目录，打开 _config.yml1234567title: xxx #博客名字description: xxx #博客描述，给搜索引擎看的author: xxx #博客作者deploy: type: git #填git，毕竟我们发布到github上 repo: xxx #https://github.com/xxxx/xxx.github.io.git,把xxx换成你博客的名字 branch: master #要发布的分支，还可以建立一个分支开管理源码，这样就和博客区分开了 写文章新建草稿1hexo n draft "文件名" //其中draft可以选择scaffolds下的名字,scaffolds下面存放的是模板 发布草稿1hexo publish draft 文件名 // 其中draft对应scaffolds文件夹下的文件名，文件名对应要发布的文件名,只有发布的才能在博客中看到 生成页面1hexo g //完整写法hexo generate 在本地启动服务器进行预览1hexo s //完整写法hexo server 在浏览器输入 http://localhost:4000 就可以预览页面 部署到服务器1234hexo d//可能碰到如下错误//ERROR Deployer not found: git 或者 ERROR Deployer //not found: github//解决方法： npm install hexo-deployer-git --save 更新更新 hexo1npm update -g hexo 更新主题12cd themes/你的主题git pull 更新插件1npm update 参考官网文档]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>